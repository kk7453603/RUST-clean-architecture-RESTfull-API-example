# Rust Clean Architecture Template для Tokio + Axum

Этот проект представляет собой полноценный шаблон чистой архитектуры на Rust с использованием Tokio и Axum.

## Архитектура

Проект следует принципам чистой архитектуры (Clean Architecture) и разделен на четыре основных слоя:

### 1. Domain Layer (Доменный слой)
- **Entities**: Бизнес-сущности (`User`, `UserId`, `Email`)
- **Value Objects**: Неизменяемые объекты с бизнес-правилами
- **Domain Services**: Бизнес-логика, не привязанная к конкретным сущностям
- **Domain Errors**: Специфичные для домена ошибки

### 2. Application Layer (Слой приложения)
- **Use Cases**: Сценарии использования бизнес-логики
- **DTOs**: Объекты для передачи данных между слоями
- **Application Services**: Координация use cases
- **Application Errors**: Ошибки уровня приложения

### 3. Infrastructure Layer (Инфраструктурный слой)
- **Repositories**: Реализация доступа к данным
- **External Services**: Интеграции с внешними сервисами
- **Configuration**: Конфигурация приложения
- **Database Adapters**: Адаптеры для работы с БД

### 4. Presentation Layer (Слой представления)
- **HTTP Handlers**: Обработчики HTTP запросов
- **Middleware**: Промежуточное ПО
- **Routers**: Маршрутизация
- **DTOs**: Объекты для сериализации/десериализации

## Структура проекта

```
src/
├── lib.rs                    # Объединенная демо-версия архитектуры
├── main.rs                   # Точка входа
├── domain/                   # Доменный слой
│   ├── entities/            # Бизнес-сущности
│   ├── value_objects/       # Объекты-значения
│   ├── services/            # Доменные сервисы
│   └── errors/              # Доменные ошибки
├── application/             # Слой приложения
│   ├── dto/                 # Объекты передачи данных
│   ├── use_cases/           # Сценарии использования
│   └── services/            # Сервисы приложения
├── infrastructure/          # Инфраструктурный слой
│   ├── repositories/        # Репозитории
│   ├── external_services/   # Внешние сервисы
│   └── config/              # Конфигурация
└── presentation/            # Слой представления
    ├── handlers/            # HTTP обработчики
    ├── middleware/          # Промежуточное ПО
    └── routers/             # Маршрутизаторы
```

## API Endpoints

### Пользователи (Users)

- `GET /health` - Проверка состояния сервера
- `POST /api/users` - Создание пользователя
- `GET /api/users/{id}` - Получение пользователя по ID
- `PUT /api/users/{id}` - Обновление пользователя
- `DELETE /api/users/{id}` - Удаление пользователя

## Примеры использования

### 1. Создание пользователя

```bash
curl -X POST http://localhost:3000/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "name": "Иван Иванов"
  }'
```

**Ответ:**
```json
{
  "success": true,
  "data": {
    "id": "uuid-string",
    "email": "user@example.com",
    "name": "Иван Иванов",
    "created_at": "2024-01-01T00:00:00Z",
    "updated_at": "2024-01-01T00:00:00Z"
  },
  "error": null
}
```

### 2. Получение пользователя

```bash
curl -X GET http://localhost:3000/api/users/{user-id}
```

### 3. Обновление пользователя

```bash
curl -X PUT http://localhost:3000/api/users/{user-id} \
  -H "Content-Type: application/json" \
  -d '{
    "email": "newemail@example.com",
    "name": "Новое имя"
  }'
```

### 4. Удаление пользователя

```bash
curl -X DELETE http://localhost:3000/api/users/{user-id}
```

## Принципы чистой архитектуры

### 1. Независимость от фреймворков
- Бизнес-логика не зависит от Axum, Tokio или других внешних библиотек
- Фреймворки могут быть заменены без изменения доменного слоя

### 2. Тестируемость
- Бизнес-правила могут тестироваться без UI, базы данных, веб-сервера
- Зависимости легко заменяются на моки

### 3. Независимость от UI
- Бизнес-правила не зависят от того, кто и как будет отображать данные
- UI может быть заменен без изменения бизнес-правил

### 4. Независимость от базы данных
- Бизнес-правила не привязаны к конкретной БД
- Можно легко переключаться между различными типами хранилищ

### 5. Внешние агентства
- Все внешние вызовы находятся во внешнем слое
- Изменения в внешнем мире не влияют на бизнес-правила

## Запуск проекта

### Требования
- Rust 1.70+
- Cargo

### Команды

```bash
# Запуск сервера
cargo run

# Сборка проекта
cargo build

# Запуск тестов
cargo test

# Провка кода
cargo check
```

## Зависимости

- **axum** - Веб-фреймворк
- **tokio** - Асинхронная среда выполнения
- **serde** - Сериализация/десериализация
- **uuid** - Генерация UUID
- **chrono** - Работа с датой и временем
- **tracing** - Логирование

## Расширение проекта

### Добавление новой сущности

1. Создайте новую сущность в `domain/entities/`
2. Добавьте соответствующие value objects в `domain/value_objects/`
3. Создайте use cases в `application/use_cases/`
4. Реализуйте repository в `infrastructure/repositories/`
5. Добавьте HTTP handlers в `presentation/handlers/`
6. Обновите router в `presentation/routers/`

### Замена хранилища данных

1. Создайте новую реализацию repository в `infrastructure/repositories/`
2. Обновите настройки в `main.rs` для использования нового repository

### Добавление валидации

1. Расширьте value objects бизнес-правилами валидации
2. Добавьте доменные ошибки для различных типов валидационных ошибок

## Тестирование

Проект включает юнит-тесты для всех слоев:

```bash
# Тесты доменного слоя
cargo test domain

# Тесты слоя приложения
cargo test application

# Интеграционные тесты
cargo test --test integration
```

## Лучшие практики

1. **Принцип единственной ответственности** - каждый модуль имеет одну причину для изменения
2. **Dependency Inversion** - зависимости направлены вверх по абстракции
3. **Interface Segregation** - клиенты не зависят от интерфейсов, которые они не используют
4. **Dependency Injection** - зависимости передаются извне, а не создаются внутри

## Лицензия

MIT License